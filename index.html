<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Comparison Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
    <!-- PDF.js for PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Mammoth.js for Word document parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        .color-same { background: #e8e8e8; }
        .color-removed { background: #ffcdd2; }
        .color-added { background: #c8e6c9; }
        .color-placeholder {
            background: repeating-linear-gradient(
                45deg,
                #d0d0d0,
                #d0d0d0 2px,
                #e8e8e8 2px,
                #e8e8e8 4px
            );
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .panel h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel h2 .stats {
            font-size: 12px;
            font-weight: normal;
            color: #666;
        }
        .input-section {
            margin-bottom: 15px;
        }
        .input-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        .file-input-wrapper {
            margin-bottom: 10px;
        }
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
            background: #fafafa;
        }
        .drop-zone:hover {
            border-color: #888;
            background: #f0f0f0;
        }
        .drop-zone.drag-over {
            border-color: #4a90d9;
            background: #e8f4fc;
        }
        .drop-zone.loading {
            opacity: 0.7;
            pointer-events: none;
        }
        .drop-zone input[type="file"] {
            display: none;
        }
        .drop-zone-text {
            color: #666;
            font-size: 13px;
        }
        .drop-zone-text small {
            display: block;
            margin-top: 5px;
            color: #999;
            font-size: 11px;
        }
        .file-status {
            margin-top: 8px;
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 4px;
            display: none;
        }
        .file-status.show {
            display: block;
        }
        .file-status.success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .file-status.error {
            background: #ffebee;
            color: #c62828;
        }
        .file-status.loading {
            background: #e3f2fd;
            color: #1565c0;
        }
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #1565c0;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 6px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #666;
        }
        .diff-display {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            background: #fafafa;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .diff-display .same {
            background: #e8e8e8;
            padding: 1px 0;
        }
        .diff-display .removed {
            background: #ffcdd2;
            padding: 1px 0;
        }
        .diff-display .added {
            background: #c8e6c9;
            padding: 1px 0;
        }
        .diff-display .placeholder {
            background: repeating-linear-gradient(
                45deg,
                #d0d0d0,
                #d0d0d0 2px,
                #e8e8e8 2px,
                #e8e8e8 4px
            );
            padding: 1px 0;
        }

        /* Center panel styles */
        .center-panel textarea {
            height: 300px;
        }
        .merge-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .merge-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .btn-left {
            background: #ffcdd2;
            color: #333;
        }
        .btn-left:hover {
            background: #ef9a9a;
        }
        .btn-right {
            background: #c8e6c9;
            color: #333;
        }
        .btn-right:hover {
            background: #a5d6a7;
        }
        .btn-clear {
            background: #e0e0e0;
            color: #333;
        }
        .btn-clear:hover {
            background: #bdbdbd;
        }
        .btn-copy {
            background: #90caf9;
            color: #333;
        }
        .btn-copy:hover {
            background: #64b5f6;
        }

        /* Chunk selection */
        .chunk-list {
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        .chunk-item {
            display: flex;
            align-items: flex-start;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            gap: 10px;
        }
        .chunk-item:last-child {
            border-bottom: none;
        }
        .chunk-item button {
            flex-shrink: 0;
            padding: 4px 10px;
            font-size: 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .chunk-text {
            flex: 1;
            font-size: 13px;
            color: #555;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .chunk-type-removed {
            background: #ffebee;
        }
        .chunk-type-added {
            background: #e8f5e9;
        }
        .chunk-type-same {
            background: #f5f5f5;
        }
        .btn-same {
            background: #e8e8e8;
            color: #333;
        }
        .btn-same:hover {
            background: #bdbdbd;
        }

        .summary {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Text Comparison Tool</h1>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color color-same"></div>
            <span>Unchanged</span>
        </div>
        <div class="legend-item">
            <div class="legend-color color-removed"></div>
            <span>Removed</span>
        </div>
        <div class="legend-item">
            <div class="legend-color color-added"></div>
            <span>Added</span>
        </div>
        <div class="legend-item">
            <div class="legend-color color-placeholder"></div>
            <span>Gap</span>
        </div>
    </div>

    <div class="container">
        <!-- Left Panel -->
        <div class="panel">
            <h2>
                Original Text
                <span class="stats" id="left-stats"></span>
            </h2>
            <div class="input-section">
                <div class="file-input-wrapper">
                    <div class="drop-zone" id="left-drop-zone">
                        <input type="file" id="left-file" accept=".txt,.md,.html,.css,.js,.json,.xml,.csv,.rtf,.pdf,.doc,.docx">
                        <div class="drop-zone-text">
                            Drop file here or click to upload
                            <small>Supports: TXT, MD, PDF, DOCX, RTF, HTML, CSS, JS, JSON, XML, CSV</small>
                        </div>
                    </div>
                    <div class="file-status" id="left-file-status"></div>
                </div>
                <textarea id="left-input" placeholder="Paste or type your original text here..."></textarea>
            </div>
            <div class="summary" id="left-summary">
                <strong>Summary:</strong> Enter text to compare
            </div>
            <div class="diff-display" id="left-diff"></div>
        </div>

        <!-- Center Panel -->
        <div class="panel center-panel">
            <h2>Merged Result</h2>
            <div class="merge-buttons">
                <button class="btn-left" onclick="useLeftText()">Use All Left</button>
                <button class="btn-right" onclick="useRightText()">Use All Right</button>
                <button class="btn-clear" onclick="clearMerged()">Clear</button>
                <button class="btn-copy" onclick="copyMerged()">Copy</button>
            </div>

            <div class="summary" id="merge-summary">
                <strong>Changes:</strong> Select chunks below to build your merged text
            </div>

            <div class="chunk-list" id="chunk-list">
                <div style="padding: 20px; color: #888; text-align: center;">
                    Enter text on both sides to see differences
                </div>
            </div>

            <label for="merged-output">Your merged text:</label>
            <textarea id="merged-output" placeholder="Build your merged text here by selecting chunks or editing directly..."></textarea>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <h2>
                Modified Text
                <span class="stats" id="right-stats"></span>
            </h2>
            <div class="input-section">
                <div class="file-input-wrapper">
                    <div class="drop-zone" id="right-drop-zone">
                        <input type="file" id="right-file" accept=".txt,.md,.html,.css,.js,.json,.xml,.csv,.rtf,.pdf,.doc,.docx">
                        <div class="drop-zone-text">
                            Drop file here or click to upload
                            <small>Supports: TXT, MD, PDF, DOCX, RTF, HTML, CSS, JS, JSON, XML, CSV</small>
                        </div>
                    </div>
                    <div class="file-status" id="right-file-status"></div>
                </div>
                <textarea id="right-input" placeholder="Paste or type your modified text here..."></textarea>
            </div>
            <div class="summary" id="right-summary">
                <strong>Summary:</strong> Enter text to compare
            </div>
            <div class="diff-display" id="right-diff"></div>
        </div>
    </div>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Elements
        const leftInput = document.getElementById('left-input');
        const rightInput = document.getElementById('right-input');
        const leftDiff = document.getElementById('left-diff');
        const rightDiff = document.getElementById('right-diff');
        const leftFile = document.getElementById('left-file');
        const rightFile = document.getElementById('right-file');
        const leftDropZone = document.getElementById('left-drop-zone');
        const rightDropZone = document.getElementById('right-drop-zone');
        const leftFileStatus = document.getElementById('left-file-status');
        const rightFileStatus = document.getElementById('right-file-status');
        const mergedOutput = document.getElementById('merged-output');
        const chunkList = document.getElementById('chunk-list');
        const leftSummary = document.getElementById('left-summary');
        const rightSummary = document.getElementById('right-summary');
        const mergeSummary = document.getElementById('merge-summary');
        const leftStats = document.getElementById('left-stats');
        const rightStats = document.getElementById('right-stats');

        let currentDiffs = [];

        // File reading - setup for both sides
        setupDropZone(leftDropZone, leftFile, leftInput, leftFileStatus);
        setupDropZone(rightDropZone, rightFile, rightInput, rightFileStatus);

        function setupDropZone(dropZone, fileInput, textarea, statusEl) {
            // Click to open file dialog
            dropZone.addEventListener('click', () => fileInput.click());

            // File input change
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    processFile(e.target.files[0], textarea, dropZone, statusEl);
                }
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files[0]) {
                    processFile(e.dataTransfer.files[0], textarea, dropZone, statusEl);
                }
            });
        }

        function showStatus(statusEl, message, type) {
            statusEl.className = 'file-status show ' + type;
            statusEl.innerHTML = type === 'loading'
                ? '<span class="spinner"></span>' + message
                : message;
        }

        function hideStatus(statusEl) {
            statusEl.className = 'file-status';
        }

        async function processFile(file, textarea, dropZone, statusEl) {
            const ext = file.name.split('.').pop().toLowerCase();

            dropZone.classList.add('loading');
            showStatus(statusEl, `Processing ${file.name}...`, 'loading');

            try {
                let text;

                if (ext === 'pdf') {
                    text = await extractPdfText(file);
                } else if (ext === 'docx') {
                    text = await extractDocxText(file);
                } else if (ext === 'doc') {
                    throw new Error('Legacy .doc format not supported. Please convert to .docx');
                } else if (ext === 'rtf') {
                    text = await extractRtfText(file);
                } else {
                    // Plain text formats
                    text = await readAsText(file);
                }

                textarea.value = text;
                updateDiff();
                showStatus(statusEl, `Loaded: ${file.name} (${formatFileSize(file.size)})`, 'success');
            } catch (error) {
                console.error('File processing error:', error);
                showStatus(statusEl, `Error: ${error.message}`, 'error');
            } finally {
                dropZone.classList.remove('loading');
            }
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function readAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        async function extractPdfText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n\n';
            }
            return fullText.trim();
        }

        async function extractDocxText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        }

        async function extractRtfText(file) {
            const text = await readAsText(file);
            // Basic RTF to plain text conversion
            // Remove RTF control words and groups
            let plain = text
                // Remove RTF header
                .replace(/^\{\\rtf1[^}]*\}/g, '')
                // Remove font tables, color tables, etc.
                .replace(/\{\\fonttbl[^}]*\}/g, '')
                .replace(/\{\\colortbl[^}]*\}/g, '')
                .replace(/\{\\stylesheet[^}]*\}/g, '')
                // Convert common RTF sequences
                .replace(/\\par\s*/g, '\n')
                .replace(/\\line\s*/g, '\n')
                .replace(/\\tab\s*/g, '\t')
                // Remove control words
                .replace(/\\[a-z]+\d*\s?/gi, '')
                // Remove remaining braces
                .replace(/[{}]/g, '')
                // Clean up whitespace
                .replace(/\n{3,}/g, '\n\n')
                .trim();

            if (!plain || plain.length < 10) {
                throw new Error('Could not extract text from RTF. Try converting to TXT first.');
            }
            return plain;
        }

        // Debounced diff update
        let debounceTimer;
        function debouncedUpdate() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(updateDiff, 300);
        }

        leftInput.addEventListener('input', debouncedUpdate);
        rightInput.addEventListener('input', debouncedUpdate);

        function updateDiff() {
            const leftText = leftInput.value;
            const rightText = rightInput.value;

            // Update stats
            leftStats.textContent = `${countWords(leftText)} words, ${leftText.length} chars`;
            rightStats.textContent = `${countWords(rightText)} words, ${rightText.length} chars`;

            if (!leftText && !rightText) {
                leftDiff.innerHTML = '<span style="color: #888;">Enter text to see comparison</span>';
                rightDiff.innerHTML = '<span style="color: #888;">Enter text to see comparison</span>';
                chunkList.innerHTML = '<div style="padding: 20px; color: #888; text-align: center;">Enter text on both sides to see differences</div>';
                leftSummary.innerHTML = '<strong>Summary:</strong> Enter text to compare';
                rightSummary.innerHTML = '<strong>Summary:</strong> Enter text to compare';
                mergeSummary.innerHTML = '<strong>Changes:</strong> Select chunks below to build your merged text';
                return;
            }

            // Use word-level diff for better readability
            const diffs = Diff.diffWords(leftText, rightText);
            currentDiffs = diffs;

            // Calculate statistics
            let addedCount = 0, removedCount = 0, unchangedCount = 0;
            let addedWords = 0, removedWords = 0;

            diffs.forEach(part => {
                const wordCount = countWords(part.value);
                if (part.added) {
                    addedCount++;
                    addedWords += wordCount;
                } else if (part.removed) {
                    removedCount++;
                    removedWords += wordCount;
                } else {
                    unchangedCount++;
                }
            });

            // Build diff displays
            let leftHtml = '';
            let rightHtml = '';

            diffs.forEach(part => {
                const escaped = escapeHtml(part.value);

                if (part.added) {
                    // Added - show on right with green, show placeholder on left
                    const placeholder = createPlaceholder(part.value);
                    leftHtml += `<span class="placeholder">${placeholder}</span>`;
                    rightHtml += `<span class="added">${escaped}</span>`;
                } else if (part.removed) {
                    // Removed - show on left with orange, show placeholder on right
                    const placeholder = createPlaceholder(part.value);
                    leftHtml += `<span class="removed">${escaped}</span>`;
                    rightHtml += `<span class="placeholder">${placeholder}</span>`;
                } else {
                    // Unchanged - show on both with grey
                    leftHtml += `<span class="same">${escaped}</span>`;
                    rightHtml += `<span class="same">${escaped}</span>`;
                }
            });

            leftDiff.innerHTML = leftHtml || '<span style="color: #888;">No text</span>';
            rightDiff.innerHTML = rightHtml || '<span style="color: #888;">No text</span>';

            // Update summaries
            leftSummary.innerHTML = `<strong>Summary:</strong> ${removedWords} words removed (${removedCount} changes)`;
            rightSummary.innerHTML = `<strong>Summary:</strong> ${addedWords} words added (${addedCount} changes)`;
            mergeSummary.innerHTML = `<strong>Changes:</strong> ${addedCount + removedCount} differences found`;

            // Build chunk list for merging
            buildChunkList(diffs);
        }

        function createPlaceholder(text) {
            // Create invisible placeholder to maintain alignment
            // Replace visible characters with spaces, keep whitespace
            return text.replace(/[^\s]/g, '\u00A0');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function countWords(text) {
            return text.trim().split(/\s+/).filter(w => w.length > 0).length;
        }

        function buildChunkList(diffs) {
            if (diffs.length === 0) {
                chunkList.innerHTML = '<div style="padding: 20px; color: #888; text-align: center;">No differences found</div>';
                return;
            }

            let html = '';
            let hasContent = false;

            diffs.forEach((part, index) => {
                // Skip empty or whitespace-only parts for same text
                const trimmed = part.value.trim();
                if (!part.added && !part.removed && trimmed.length === 0) {
                    return;
                }

                hasContent = true;
                let typeClass, btnClass, label;

                if (part.added) {
                    typeClass = 'chunk-type-added';
                    btnClass = 'btn-right';
                    label = 'Add';
                } else if (part.removed) {
                    typeClass = 'chunk-type-removed';
                    btnClass = 'btn-left';
                    label = 'Keep';
                } else {
                    typeClass = 'chunk-type-same';
                    btnClass = 'btn-same';
                    label = 'Common';
                }

                const preview = part.value.length > 100 ? part.value.substring(0, 100) + '...' : part.value;

                html += `
                    <div class="chunk-item ${typeClass}">
                        <button class="${btnClass}" onclick="addChunk(${index})">${label}</button>
                        <div class="chunk-text">${escapeHtml(preview)}</div>
                    </div>
                `;
            });

            if (!hasContent) {
                chunkList.innerHTML = '<div style="padding: 20px; color: #888; text-align: center;">No content to display</div>';
            } else {
                chunkList.innerHTML = html;
            }
        }

        function addChunk(index) {
            const chunk = currentDiffs[index];
            if (chunk) {
                const textarea = mergedOutput;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;

                let chunkValue = chunk.value;
                const firstChar = chunkValue.charAt(0);
                const charBeforeCursor = start > 0 ? text.charAt(start - 1) : '';

                // Punctuation that should not have a space before it
                const punctuation = /^[.,!?;:'")\]\}>\-\u2019\u201D]/;

                // Add space if: there's text before cursor, it doesn't end with whitespace,
                // and the chunk doesn't start with punctuation
                if (charBeforeCursor && !/\s/.test(charBeforeCursor) && !punctuation.test(firstChar)) {
                    chunkValue = ' ' + chunkValue;
                }

                textarea.value = text.substring(0, start) + chunkValue + text.substring(end);
                textarea.focus();
                textarea.selectionStart = textarea.selectionEnd = start + chunkValue.length;
            }
        }

        function useLeftText() {
            mergedOutput.value = leftInput.value;
        }

        function useRightText() {
            mergedOutput.value = rightInput.value;
        }

        function clearMerged() {
            mergedOutput.value = '';
        }

        function copyMerged() {
            mergedOutput.select();
            navigator.clipboard.writeText(mergedOutput.value).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 1500);
            });
        }

        // Example text for demonstration
        const exampleLeftText = `Once upon a time there was a giant toad who lived beneath an ancient oak tree. üê∏

Much like Virgil's Aeneas wandering through unknown lands, this toad had journeyed far from the marshes of its birth. The creature possessed wisdom as deep as the verses in the Beowulf manuscript‚Äîthat singular parchment survivor of a thousand years.

In the evenings, the toad would sit upon a mossy stone and contemplate the nature of existence. "To croak, or not to croak," it would muse, channeling the spirit of Shakespeare's original quartos. The stars above seemed to whisper secrets, ancient as the Epic of Gilgamesh etched on clay tablets in distant Mesopotamia.

The other creatures of the forest regarded the toad with reverence. üåø Even the wise owl, who had read every manuscript in Canterbury, admitted the toad's philosophical depth was unmatched.`;

        const exampleRightText = `Once upon a time, a giant toad ate the world. üåç

Like Homer's Odysseus consuming the lotus flower's knowledge, this magnificent amphibian swallowed continents whole. The creature's hunger was legendary‚Äîits appetite rivaling the ambition found in Milton's Paradise Lost, where even angels dared to reach beyond their station.

In the evenings, the toad would sit upon a throne of mountains and contemplate its vast domain. "To devour, or not to devour," it would thunder, its voice echoing like the revisions between Shakespeare's First Folio and the earlier quartos. The galaxies above seemed to tremble, ancient as the Dead Sea Scrolls hidden in their desert caves.

The other creatures of the cosmos regarded the toad with terror. üåü‚ú® Even the celestial serpent, who had witnessed the burning of the Library of Alexandria, admitted the toad's destructive majesty was unparalleled.`;

        // Initialize with example text
        leftInput.value = exampleLeftText;
        rightInput.value = exampleRightText;
        updateDiff();
    </script>
</body>
</html>
